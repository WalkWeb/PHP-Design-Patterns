<?php

namespace Patterns\Creational\Singleton;

/**
 * Singleton
 *
 * Синглтон написан таким образом, чтобы сколько раз его не создавали - он возвращает себя в единственном экземпляре,
 * т.е. везде это будет один и тот же объект.
 *
 * ПРИМЕНЕНИЕ:
 *
 * - Подключение к базе - если создавать подключение к базе обычным объектом, то на каждое создание такого объекта
 * будет создаваться отдельное подключение. Что, банально, может привести к ошибке "User has already more than max
 * active connections"
 *
 * - Любые ситуации, где у нас создается большая и сложная сущность, которая используется в разных частях фреймворка
 * (в middleware, в контроллере, в моделях), но при этом нам критична производительность, и создавать её каждый
 * раз с нуля (а при создании, к примеру, делается 20 запросов в базу) слишком накладно.
 *
 * НЕДОСТАТКИ:
 *
 * - Сложнее тестировать
 *
 * @package Patterns
 */
class Singleton
{
    /** @var Singleton - здесь хранится сам объект класса */
    private static $instance;

    /**
     * Единственный метод, через который можно получить объект Singleton, и, который, собственно реализует логику
     * синглтона.
     *
     * @return Singleton
     */
    public static function getInstance(): Singleton
    {
        if (static::$instance === null) {
            static::$instance = new self;
        }

        return static::$instance;
    }

    /**
     * Защищаем наш синглтон от создания класса напрямую
     */
    private function __construct() {}

    /**
     * Защищаем наш синглтон от клонирования
     */
    private function __clone() {}

    /**
     * Блокируем сериализацию объекта
     *
     * phpStorm ругается на приватность этого метода, но на работу синглтона это никак не влияет
     */
    private function __sleep() {}

    /**
     * Ну и unserialize() на всякий случай
     *
     * phpStorm ругается на приватность этого метода, но на работу синглтона это никак не влияет
     */
    private function __wakeup() {}
}
