<h1>Strategy (Стратегия)</h1>

<p>
    <i>Применение: простое изменение логики/поведения объекта без необходимости изменять код самого объекта</i>
</p>

<p>
    Паттерн Стратегия легко понять, если вы уже разобрались с паттерном Внедрение Зависимости. Вся разница между ними
    в том, что если обычно, при внедрении зависимости внедряются данные (хотя и не обязательно только они), то в
     Стратегии внедряется именно логика.
</p>

<p>
    Рассмотрим практическую задачу.
</p>

<p>
    Мы разрабатываем поведение ботов в игре. Чтобы их поведение было более разнообразным мы хотим создать характеры 
    поведений — когда один и тот же тип игрового юнита по разному поступал в одинаковых ситуаций. Например один сражался 
    до последнего, а другой, при встрече с врагом убегал (или убегал, при получении значительных повреждений).
</p>

<p>
    При этом мы хотим добавлять новые характеры поведений так, чтобы не приходилось изменять основной код бота.
</p>

<p>
    Приступим. Вначале напишем интерфейс бота. Для примера предельно простой — имя и обработка встречи с врагом, при 
    этом действие возвращается в виде строки (в реальном коде может возвращаться объект конкретного действия юнита, и 
    применяться к нему же)
</p>

    interface UnitInterface
    {
        public function getName(): string;
    
        /**
         * Для простоты примера метод просто возвращает текстовое описание, что бот будет делать при встрече с врагом
         *
         * @return string
         */
        public function atMeetingEnemy(): string;
    }

<p>
    Теперь интерфейс характера. С одним методов — поведение при встрече с врагом.
</p>

<p>
    Разумеется, в реальном проекте методов может быть больше, и самих стратегий у бота может быть больше — стратегии 
    боя, передвижения, строительства, добычи ресурсов и так далее — каждое из этих поведений можно сделать различных для 
    разных «характеров» ботов.
</p>

    interface StrategyInterface
    {
        public const MEETING_ENEMY_FIGHT  = 'При встрече с врагом вступаю в бой';
        public const MEETING_ENEMY_ESCAPE = 'При встрече с врагом убегаю';
    
        public function atMeetingEnemy(): string;
    }

<p>
    А теперь реализация юнита, и сама реализация Стратегии:
</p>

    class Unit implements UnitInterface
    {
        /**
         * @var string
         */
        private $name;
    
        /**
         * @var StrategyInterface - Определяет, как бот будет поступать в различных ситуациях, например, при встрече врага
         */
        private $strategy;
    
        public function __construct(string $name, StrategyInterface $strategy)
        {
            $this->name = $name;
            $this->strategy = $strategy;
        }
    
        public function getName(): string
        {
            return $this->name;
        }
    
        public function atMeetingEnemy(): string
        {
            return $this->strategy->atMeetingEnemy();
        }
    }

<p>
    В итоге, указывая необходимую стратегию поведения при создании объекта мы меняем его поведение в одной и той же 
    ситуации.
</p>

<p>
    Пример использования можно посмотреть в тестах.
</p>
