
# Паттерн Внедрение Зависимостей (Dependency Injection)

Пожалуй самый простой паттерн из всех. Он на столько прост, что даже трудно объяснить его тому, кто о нем не знает 
(хотя, возможно, и использует в работе). Академическим языком он звучит так: «процесс предоставления внешней зависимости 
программному компоненту». Но, согласитесь, мало о чем говорит.

Чтобы понять что такое паттерн Внедрение Зависимостей лучше всего пойти от обратного - показать примеры плохого кода,
и постепенно улучшая его дойти до данного паттерна.

## Вариант первый - «гвозди»

Допустим, нам необходимо создать объект школьника с именем Вася. И мы можем реализовать его так:

```php
class Schoolboy
{
    private $name = 'Вася';

    public function getName(): string
    {
        return $this->name;
    }
}
```

Проблема такой реализации - имя Вася забито «гвоздями». Чтобы изменить имя – придется переписывать класс.

*Примечание*

*Кстати, у читателя, если он только начинает изучать программирование может возникнуть вопрос – а зачем делать свойство 
имени приватным, если можно сделать public. И тогда его можно изменить имя в любом месте. В этом и проблема такого 
подхода – а что если мы хотим, чтобы имя школьника задавалось только один раз при создании класса? Мы не можем это 
гарантировать в таком подходе. И внезапно школьник Вася через тысячи строк кода может оказаться школьницей Маша. Чтобы
этого не было – все свойства класса по-умолчанию делаются приватными, а те, что могут изменяться – изменяются через 
публичные методы.*

## Второй вариант - невалидные объекты

Мы можем улучшить первый вариант и сделать его таким:

```php
class Schoolboy
{
    /**
     * @var string
     */
    private $name;

    public function getName(): string
    {
        return $this->name;
    }

    public function setName(string $name): void
    {
        $this->name = $name;
    }
}
```

Имя школьника не задается «гвоздями», а задается отдельным методом. К сожалению, значительная часть программистов
застревают на этом уровне «хорошего» кода. А в чем его проблема? В том, что имя школьника – это обязательный параметр,
а в таком варианте его может отсутствовать. Один программист после создания объекта вызовет метод setName() и укажет имя, а 
другой программист забудет это сделать, и при обращении к имени получим ошибку php, потому что метод ожидает, что вернет
string, а вернет null.

## Вариант третий - простой пример внедрения зависимости

Следующее улучшение нашего кода – это как раз внедрение зависимости. Мы сразу, при создании объекта передаем ему имя
школьника:

```php
class Schoolboy
{
    /**
     * @var string
     */
    private $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function getName(): string
    {
        return $this->name;
    }
}
```

Мы получаем объект, который сразу, при создании, будет требовать, чтобы ему передали имя школьника. В отличие от 
предыдущего примера, это пример хорошего объекта – который или создается, и имеет полноценное состояние (он имеет все 
свойства/параметры для своей работы). Или ошибка происходит на уровне создания. В противоположность объектам, которые 
вроде и созданы, на при работе с ними в любой момент может возникнуть проблема, потому что вдруг оказалось, что какой-то 
обязательный параметр в нем не указан.

Плюс к этому, мы хотели, чтобы имя у школьника задавалось только один раз при создании, и не менялось больше в процессе
работы программы – так и получаем в данном примере. 

## Вариант третий - немного более сложный пример

Но это был простейший пример. Представим, что объект школьника должен также знать название школы, в которой он учится.
Можно просто добавить параметр $schoolName и задавать его также через конструктор.

Но мы можем реализовать паттерн внедрения полноценно, и использовать его для реализации гибкой и расширяемой 
архитектуры.

Во-первых, мы создадим класс школы, название которой также задается через конструктор:

```php
class School
{
    private $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function getName(): string
    {
        return $this->name;
    }
}
```

И мы уже её можем передавать в конструктор. Хотя можно сделать еще гибче – а вдруг у нас появятся разные типы школ, со
своими реализациями. Лучше сразу делать от интерфейсов:

```php
interface SchoolInterface
{
    public function getName(): string;
}

class School implements SchoolInterface
{
    private $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function getName(): string
    {
        return $this->name;
    }
}
``` 

И теперь в классе школьника привяжемся не к классу, а к интерфейсу (что позволит принимать объект любого класса, который
реализует интерфейс SchoolInterface):

```php
class SchoolboyDI
{
    private $name;

    private $school;

    /**
     * @param string $name
     * @param SchoolInterface $school
     */
    public function __construct(string $name, SchoolInterface $school)
    {
        $this->name = $name;
        $this->school = $school;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function getSchool(): SchoolInterface
    {
        return $this->school;
    }
}
```

Что мы получаем в таком варианте? Что класс школы может меняться, в нем могут появляться новые методы, и нам не нужно
как-то править класс SchoolboyDI, чтобы работать с ними.

Можно пойти еще дальше. Сделав интерфейс абстрактного ученика, и интерфейс абстрактного учебного заведения. А школьник,
студен, школа, институты и прочие конкретные реализации будут уже реализовывать два этих базовых интерфейса.

В любом случае, на данном этапе паттерн внедрения зависимостей должен быть понятен – нужные параметры (зависимости) 
объекта передаем в конструктор.
